# finalizer와 cleaner 사용을 피하라

자바는 두 가지 객체 소멸자를 제공하는데, finalizer는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요.

자바 9에서는 finalizer를 deprecated API로 지정하고 cleaner를 그 대안으로 소개했지만, 여전히 예측할 수 없고, 느리고 일반적으로 불필요.

자바의 finalizer와 cleaner는 C++의 dsstructor와는 다른 개념으로, C++의 dsstructor는(생성자의 꼭 필요한 대척점으로) 특정 객체와 관련된 자원을 회수하는 보편적인 방법

자바는 접근할 수 없게 된 객체를 회수하는 역할을 가비지 컬렉터가 담당하고, 프로그래머에게는 아무런 작업을 요구하지 않음.

C++의 dsstructor는 비메모리 자원을 회수하는 용도로 쓰이지만, 자바는 try-with-resources와 try-finally를 사용하여 해결

## 예측 불가한 실행 시점

finalizer와 cleaner 즉시 수행된다는 보장이 없어서 제때 실행되어야 하는 작업은 절대 할 수 없음. 예를 들어 파일 닫기를 finalizer나 cleaner에 맡기면 시스템이 동시에 열 수 있는 파일에 한계가 있기에 중대한 오류를 일으킬 수 있음

finalizer나 cleaner가 얼마나 신속히 수행할지는 전적으로 가비지 컬렉터 알고리즘에 달렸으며, 이는 가비지 컬렉터 구현마다 천차만별이며, 수행 시점에 의존하는 프로그램의 동작또한 마찬가지임. 예를 들어 테스트에서는 완벽하게 동작했지만, 고객의 시스템에서는 재앙이 발생할수 있음

굼뜬 finalizer처리는 실무에서도 문제가 되는데, 클래스에 finalizer를 달아두면 그 인스턴스의 자원 회수가 지연될수 있음. 예시로 원인을 알수없는 OOM이 발생하며 죽는 애플리케이션을 분석해보면 객체 수천 개가 finalizer 대기열에서 회수되기만을 기다리는 문제로, finalizer 스레드는 다른 애플이케이션 스레드보다 우선 순위가 낮아서 실행될 기회를 얻지 못하는 문제임

한편 cleaner는 자신을 수행할 스레드를 제어할 수 있다는 면에서 조금 낫지만, 여전히 백그라운드에서 수행되며 가비지 컬렉터의 통제하에 있어 즉각 수행되리라는 보장은 없음.

자바 언어 명세는 finalizer와 cleaner의 수행 시점뿐 아니라 수행 여부조차도 보장하지 않는데, 접근할 수 없는 일부 객체에 딸린 종료 작업을 전혀 수행하지 못한 채 프로그램이 중단될수도 있음. 따라서 프로그램 생애주가와 상관없는, 상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존해서는 안됨. 예를 들어 데이터베이스 같은 공유 자원의 영구 락 해제를 finalizer나 cleaner에 맡겨 놓으면 분산 시스템 전체가 서서히 멈출것임

System.gc나 System.runFinalization 메서드는 finalizer와 cleaner를 실행될 가능성을 높여줄수는 있으나 보장해주지 않고, System.runFinalizersOnExit와 Runtime.runFinalizersOnExit는 심각현 결함이 있음

## 예외 처리

또한 finalizer 동작중 발생하는 예외는 무시되며 처리할 작업이 남아있더라도 그 순간 종료되며, 잡지 못한 예외 때문에 해당 객체는 마무리가 덜 된 상태로 남아있고, 다른 스레드가 이 훼손된 객체를 사용하면 어떻게 동작할지 예측할 수 없음. 보통의 경우에는 잡지 못한 예외가 스레드를 중단시키고 stack trace를 출력하지만, finalizer에서 발생한다면 경고조차 출력하지 않으나, cleaner를 사용하는 라이브러리는 자신의 스레드를 통제하기 때문에 이러한 문제는 발생하지 않음

## 성능 문제

finalizer와 cleaner는 심각한 성능 문제도 동반하는데, finalizer는 가비지 컬렉터의 효율을 떨어트리며, cleaner도 클래스의 모든 인스턴스를 수거하는 형태로 사용하면 성능은 finalizer와 비슷

## 보안 문제

finalizer는 심각한 보안 문제도 동반하는데, 생성자나 직렬화 과정에서 예외가 발생하면, 이 생성되다 만 객체에서 악의적인 하위 클래스의 finalizer가 수행될 수 있게 됨. 이 finalizer는 정적 필드에 자신의 참조를 할당하여 가비지 컬렉터가 수집하기 못하게 막을 수 있고, 이런 일그러진 객체가 만들어지면, 이 객체의 메소드를 호출해 애초에는 허용되지 않았을 작업을 수행하는 건 일도 아님. 객체 생성을 막으려면 생성자에서 예외를 던지는 것만으로 충분하지만, finalizer가 있다면 그렇지 않게 됨

## 대안

그렇다면 파일이나 스레드 등 종료해야할 자원을 담고 있는 객체의 클래스에서 finalizer와 cleaner를 대신해줄 묘안은 무엇일까? 답은 간단하다 AutoCloseable을 구현해주고 클라이언트에서 인스턴스를 다 쓰고 나면 close 메소드를 호출하면 됨(일반적으로 예외가 발생해도 제대로 종료되도록 try-with-resources를 사용). 구체적인 구현법과 관련하여 각 인스턴스는 자신이 닫혔는지를 추적하는 것이 좋은데, close 메소드에서 이 객체는 더 이상 유효하지 않음을필드에 기록하고, 다른 메소드는 이 필드를 검사해서 객체가 닫힌 후에 불렸다면 IllegalStateException을 던지는 것

## 사용 용도

finalizer와 cleaner는 언제 사용할까? 적절한 쓰임새는 두 가지 정도가 있으며, 첫번째는 자원의 소유자가 close 메소드를 호출하지 않는 것에 대비한 안전망 역할로, finalizer와 cleaner가 즉시 호출되라는 보장은 없지만, 클라이언트가 하지 않는 자원 회스룰 늦게나마 하는게 안하는 것보다는 낫은데, 이런 안전망 역할을 위해 finalizer를 작성하는 것이 그럴 가지가 있는지 확인이 필요하며, 자바 라이브러리의 일부 클래스는 안전망 역할의 finalizer를 제공 (FileInputStream, FileOutputStream, ThreadPoolExecutor)

두번째는 native peer와 연결된 객체로, 네이티브 피어란 일반 자바 객체가 네이티브 메소드를 통해 기능을 위임한 네이티브 객체를 말함. 네이티브 피어는 자바 객체가 아니니 가비지 컬렉터는 그 존재를 알 수 없음. finalizer나 cleaner가 나서서 처리하기 적당한 작업이지만, 성능 저하를 감당할 수 있고, 네이티브 피어가 심각한 자원을 가지고 있지 않을 때만 해당됨. 그렇지 않다면 close 메소드를 사용

cleaner는 사용하기에 까다로운 부분이 있는데, 예시로 Room 클래스 자원을 수거하기 전에 반드시 clean을 해야한다고 가정하고, Room 클래스는 AutoCloseable을 구현

자동 청소 안전망이 cleaner를 사용할지 말지는 순전히 내부 구현 방식의 문제로, finalizer와 달리 cleaner는 클래스의 public API에 나타나지 않음.

```java
public class Room implements AutoCloseable {
    private static final Cleaner cleaner = Cleaner.create();

    // 청소가 필요한 자원, 절대 Room을 참조해서는 안됨
    private static class State implements Runnable {
        int numJunkPiles; // Room 안의 쓰레기 수

        State(int numJunkPiles) {
            this.numJunkPiles = numJunkPiles;
        }

        // close 메소드나 cleaner가 호출
        @Override
        public void run() {
            System.out.println("방 청소");
            numJunkPiles = 0;
        }
    }

    // 방의 상태. cleanable과 공유
    private final State state;

    // cleanable 객체, 수거 대상이 되면 방을 청소
    private final Cleaner.Cleanable cleanable;

    public Room(int numJunkPiles) {
        state = new State(numJunkPiles);
        cleanable = cleaner.register(this, state);
    }

    @Override
    public void close() {
        cleanable.clean();
    }
}
```

static으로 선언된 중첩 클래스인 State는 cleaner가 방을 청소할때 수거할 자원을 담고 있고, numJunkPiles 필드가 수거할 자원에 해당하는데, 더 현실적으로 만들려면 이 필드는 네이티브 피어를 가리키는 포인터를 담은 final long 변수여야 함.

State는 Runnable을 구현하고, 그 안의 run 메소드는 cleanable에 의해 딱 한 번만 호출 되고, 이 cleanable 객체는 Room 생성자에서 cleaner에 Room과 State를 등록할 때 얻음

run 메소드가 호출되는 상황은 둘 중 하나로, 보통은 Romm의 close를 호출할 떼, close 메소드에서 Cleanable의 clean을 호출하면 이 메소드 안에서 run을 호출, 또는 가비지 컬렉터가 Room을 회수할 때까지 클라이언트가 close를 호출하지 않는다면, cleaner가 (바라건대) State의 run 메소드를 호출

주의할 점으로 State 인스턴스는 절대로 Room 인스턴스를 참조하면 안되는데, Room 인스턴스를 참조할 경우 순환참조가 생겨 가비지 컬렉터가 Room 인스턴스를 회수해갈 (따라서 자동 청소) 기회가 오지 않음. State가 정적 중첩 클래스인 이유가 정적이 아닌 중첩 클래스는 자동으로 바깥 객체의 참조를 갖게 되기 때문. 이와 비슷하게 람다 역시 바깥 객체의 참조를 갖기 쉬우니 사용하지 않는 것이 좋음

앞서 이야기한 대로 Room의 cleaner는 단지 안전망으로만 쓰였고, 클라이언트가 모든 Room 생성을 try-with-resource 블록으로 감쌌다면 자동 청소는 전혀 필요하지 않음

다음은 잘 짜인 클라이언트 코드

```java
public class Adult {
    public static void main(String[] args) {
        try (Room room = new Room(7)) {
            System.out.println("hello");
        }
    }
}
```

기대한 대로 Adult 프로그램은 hello을 출력한 후, "방 청소"를 출력함

다음은 방 청소를 하지 않는 클라이언트 코드

```java
public class Teenager {
    public static void main(String[] args) {
        new Room(99);
        System.out.println("anyway");
    }
}
```

anyway에 이어 "방 청소가" 출력되리라 기대했지만, 출력되지 않을 수도 있다. 이는 앞서 말한 예측 불가한 상황으로 cleaner의 명세에는 다음과 같이 표현함

> System.exit을 호출할 때의 cleaner 동작은 구현하기 나름이다. 청소가 이뤄질지는 보장하지 않음

이는 일반 프로그램에서도 마찬가지임. System.gc()로 종료전에 "방 청소"를 출력할수도 있지만 보장은 안됨

## 핵심 정리

cleaner(자바 8까지는 finalizer)는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 사용 물론 이런 경우라도 불확실성과 성능 저하에 주의해야 함.
