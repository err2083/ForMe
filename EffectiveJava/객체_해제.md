# 다 쓴 객체 참조를 해제하라

C, C++ 처럼 메모리를 직접 관리하는 언어에서 자바처럼 가비지 컬렉터를 갖춘 언어를 사용하면 메모리 관리에 신경을 안써도 된다고 생각하지만 사실이 아님

```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0) {
            throw new EmptyStackException();
        }
        return elements[--size];
    }

    private void ensureCapacity() {
        if (elements.length == size) {
            elements = Arrays.copyOf(elements, 2 * size + 1);
        }
    }
}
```s

특별한 문제가 없어보이지만 메모리 누수라는 문제가 존재함. 이 스택을 오래 사용하는 프로그램은 점차 가비지 컬렉션 활동과 메모리 사용량이 늘어나 성능이 저하됨

스택이 커졌다가 줄어들었을 때 스택에서 꺼내진 객체들을 가비지 컬렉테가 회수 하지 않아서 메모리 누수가 발생. 이는 프로그램이 그 객체를 더 이상 사용하지 않아도 스택이 그 객체들의 다 쓴 참조를 가지고 있기 때문

가비지 컬렉션 언어에서는 (의도치 않게 살려두는) 메모리 누수를 찾기가 까다로움 이는 객체 참조 하나를 살려두면 그 객체가 참조하는 모든 객체를 회수하지 못함

해법은 간단하게 해당 참조를 다 썼을때 null 처리(참조 해제).

```java
public Object pop() {
    if (size == 0) {
        throw new EmptyStackException();
    }
    Object result = elements[--size];
    elements[size] = null;
    return result
}
```

이는 null 처리한 참조를 실수로 사용했을때 NPE 에러 처리까지 되는 장점이 존재(미리 null처리 하지 않으면 의도한 로직이 아닌 로직을 수행)

물론 모든 객체를 다 쓰자마자 일일이 null 처리할 필요는 없음. 객체 참조를 null 처리하는 일은 예외적인 경우로 다 쓴 객체 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효 범위(scope) 밖으로 밀어내는 것.

만일 변수의 범위를 최소가 되게 정의 했다면 이 일은 자연스럽게 처리됨

null 처리는 언제 해야하며, Stack 클래스가 메모리 누수에 취약한 이유는 스택이 자기 메모리를 관리하기 떄문. 객체 자체가 아니라 elements 베열로 저장수 풀을 만들어서 원소를 관리하는데, 배열의 활성화 영역과 비활성화 영역을 가비지 컬렉터가 확인할 방법이 존재하지 않음

일반적으로 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의가 필요. 원소를 다 사용한 즉시 그 원소가 참조한 객체들을 다 null 처리

캐시 역시 메모리 누수를 일으키는 주범으로 객체 참조를 캐시에 넣고 그냥 놔두는 일을 자주 접할수 있음. 만일 캐시 외부에서 키(key)를 참조하는 동안만 캐시가 필요한 상황이라면 WeakHashMap을 사용해 케시를 생성, 그러면 다 쓴 엔트리는 자동으로 제거

캐시를 만들 때 보통은 캐시 엔트리의 유효 시간을 정확히 정의하기 어렵기 때문에 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식을 흔히 사용, 이는 엔트리를 (ScheduledThreadPoolExecutor 같은) 백그라운드 스레드를 활용하거나 새 엔트리를 추가할 때 부수작업으로 쓰지 않는 엔트리를 청소하는 방법이 존재. LinkedHashMap은 removeEldestEntry 메소드를 써서 후자의 방식으로 처리하며, 복잡한 캐시를 만들고 싶다면 java.lang.ref 패키지를 직접 활용

메모리 누수의 세 번째 주범은 리스너(listener) 또는 콜백(callback) 으로 클라이언트가 콜백을 등록만 하고 해지하지 않음. 이럴 때 콜백은 약한 참조로 저장(예를 들면 WeakHashMap)하면 가비지 컬렉터가 즉시 수거
